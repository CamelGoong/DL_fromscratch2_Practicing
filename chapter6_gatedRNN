# RNN의 역전파시 MatMul 노드를 지날 떄마다 기울기의 변화
import numpy as np
import matplotlib.pyplot as plt
N = 2 # 미니배치 크기
H = 3 # 은닉 상태 벡터의 차원수
T = 20 # 시계열 데이터의 길이

dh = np.ones((N, H))
np.random.seed(3) # 재현할 수 있도록 난수의 seed 고정
# Wh = np.random.randn(H, H) # wh의 초깃값 변경 전 -> 기울기 폭발
Wh = np.random.randn(H, H) * 0.5 # Wh의 초깃값 변경 후 -> 기울기 소실
norm_list = []
for t in range(T):
  dh = np.matmul(dh, Wh.T)
  norm = np.sqrt(np.sum(dh**2)) / N
  norm_list.append(norm)

plt.plot(range(T), norm_list)
plt.xlabel('time step')
plt.ylabel('norm')
plt.show()

# 기울기 클리핑 함수 구현
import numpy as np

dW1 = np.random.randn(3, 3) * 10
dW2 = np.random.randn(3, 3) * 10
grads = [dW1, dW2]
max_norm = 5.0

def clip_grads(grads, max_norm):
  total_norm = 0
  for grad in grads:
    total_norm += np.sum(grad**2)
    toal_norm += np.sqrt(total_norm)

    rate = max_norm / total_norm + 1e-6
    if rate < 1:
      for grad in grads:
        grad *= rate
# 최초의 한 단계만 처리하는 LSTM 클래스 구현)
import numpy as np
class LSTM:
  def __init__(self, Wx, Wh, b):
    self.params = [Wx, Wh, b]
    self.grads = [np.zeros_like(Wx), np.zeros_like(Wh), np.zeros_like(b)]
    self.cache = None
  
  def forward(self, x, h_prev, c_prev):
    Wx, Wh, b = self.params
    N, H = h_prev.shape

    A = np.matmul(x, Wx) + np.matmul(h_prev, Wh) + b # f, g, i, o가 기본적으로 계산식이 같기 때문에 이렇게 한 식을 통일

    # slice
    f = A[:, :H]
    g = A[:, H:2*H]
    i = A[:, 2*H:3*H]
    o = A[:, 3*H:]

    f = sigmoid(f)
    g = np.tanh(g)
    i = sigmoid(i)
    o = sigmoid(o)

    c_next = f * c_prev + g * i
    h_next = o * np.tanh(c_next)

    self.cache = (x, h_prev, c_prev, i, f, g, o, c_next)
    return c_next, h_next

    # 역전파는 밑의 한줄로 끝낼 수 있음.
  # dA = np.hstack((df, dg, di, do)) # hstack()은 주어진 배열들을 가로로 연결하는 것.
  
 # Time LSTM 클래스 구현
import numpy as np
class TimeLSTM:
  def __init__(self, Wx, Wh, b, stateful = False):
    self.params = [Wx, Wh, b]
    self.grads = [np.zeros_like(Wx), np.zeros_like(Wh), np.zeros_like(b)]
    self.layers = None
    self.h, self.c = None, None
    self.stateful = stateful
  
  def forward(self, xs):
    Wx, Wh, b = self.params
    N, T, D = xs.shape
    H = Wh.shape[0]

    self.layers = []
    hs = np.empty((N, T, H), dtype = 'f')

    if not self.stateful or self.h is None:
      self.h = np.zeros((N,H), dtype = 'f')

      for t in range(T):
        layer = LSTM(*self.params)
        self.h, self.c = layer.forward(xs[:, t, :], self.h, self.c)
        hs[:, t, :] = self.h

        self.layers.append(layer)

      return hs

    def backward(self, dhs):
      Wx, Wh, b = self.params
      N, T, H = dhs.shape
      D = Wx.shape[0]

      dxs = np.empty((N, T, D), dtype = 'f')
      dh, dc = 0, 0

      grads = [0, 0, 0]
      for t in reversed(range(T)):
        layer = self.layers[t]
        dx, dh, dc = layer.backward(dhs[:, t, :] + dh, dc)
        dxs[:, t, :] = dx
        for i, grad in enumerate(layer.grads):
          grads[i] += grad
      for i, grad in enumerate(grads):
        self.grads[i][...] = grad

      return dxs
    
    def set_state(self, h, c = None):
      self.h, self.c = h, c

    def reset_state(self):
      self.h, self.c = None, None

